name: Cleanup untagged packages
description: "A simple action to remove untagged packages from the container registry"
author: "Gerard Braad <me@gbraad.nl>"
inputs:
  package:
    description: "Name of the container registry package"
    required: true
    type: string
  token:
    required: false
    type: string
    default: ${{ github.token }}
  owner:
    required: false
    type: string
    default: ${{ github.repository_owner }}
runs:
  using: 'composite'
  steps:
    - name: Cleanup
      id: cleanup
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const owner = '${{ inputs.owner }}';
          const packageName = '${{ inputs.package }}';
          
          console.log(`Cleaning up untagged versions for ${owner}/${packageName}`);
          
          try {
            // First determine if the owner is an org or a user
            let ownerType;
            try {
              await github.rest.orgs.get({
                org: owner
              });
              ownerType = 'org';
            } catch (err) {
              if (err.status === 404) {
                ownerType = 'user';
              } else {
                throw err;
              }
            }
            
            console.log(`Owner type determined as: ${ownerType}`);
            
            // Get package versions
            let packageVersions;
            if (ownerType === 'org') {
              const response = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                package_type: 'container',
                package_name: packageName,
                org: owner
              });
              packageVersions = response.data;
            } else {
              const response = await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                package_type: 'container',
                package_name: packageName,
                username: owner
              });
              packageVersions = response.data;
            }
            
            console.log(`Found ${packageVersions.length} package versions`);
            
            // Process each package version
            let successCount = 0;
            let failCount = 0;
            
            for (const version of packageVersions) {
              if (!version.metadata.container.tags || version.metadata.container.tags.length === 0) {
                console.log(`Attempting to delete untagged version ${version.id}`);
                
                try {
                  if (ownerType === 'org') {
                    await github.rest.packages.deletePackageVersionForOrg({
                      package_type: 'container',
                      package_name: packageName,
                      org: owner,
                      package_version_id: version.id
                    });
                  } else {
                    await github.rest.packages.deletePackageVersionForUser({
                      package_type: 'container',
                      package_name: packageName,
                      username: owner,
                      package_version_id: version.id
                    });
                  }
                  
                  console.log(`Successfully deleted version ${version.id}`);
                  successCount++;
                } catch (deleteErr) {
                  console.log(`Failed to delete version ${version.id}: ${deleteErr.message}`);
                  failCount++;
                  
                  // Try with the octokit.request method as a backup approach
                  try {
                    console.log(`Trying alternative deletion method for version ${version.id}`);
                    const endpoint = ownerType === 'org' 
                      ? `DELETE /orgs/${owner}/packages/container/${packageName}/versions/${version.id}` 
                      : `DELETE /users/${owner}/packages/container/${packageName}/versions/${version.id}`;
                      
                    await github.request(endpoint, {
                      headers: {
                        'X-GitHub-Api-Version': '2022-11-28'
                      }
                    });
                    console.log(`Alternative deletion method succeeded for version ${version.id}`);
                    successCount++;
                    failCount--; // Correct the count since we succeeded on retry
                  } catch (altErr) {
                    console.log(`Alternative deletion also failed: ${altErr.message}`);
                  }
                }
              } else {
                console.log(`Skipping version ${version.id} as it has ${version.metadata.container.tags.length} tags`);
              }
            }
            
            console.log(`Deletion summary: ${successCount} succeeded, ${failCount} failed`);
            
            if (failCount > 0) {
              core.warning(`Failed to delete ${failCount} package versions`);
            }
            
          } catch (error) {
            console.error(`Error in cleanup process: ${error.message}`);
            if (error.status) console.error(`Status code: ${error.status}`);
            core.setFailed(error.message);
          }
